#!/usr/bin/env python

# lsseq - List directory contents while compressing images sequences to
# one entry each.  Filenames that are part of images sequences are
# assumed to be of the form:
#     <descriptiveName>.<frameNum>.<imgExtention>

# Copyright (c) 2008-2010, James Philip Rowell,
# Orange Imagination & Concepts, Inc.
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#   - Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#   - Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
#   - Neither the name "Orange Imagination & Concepts, Inc." nor the
#     names of its contributors may be used to endorse or promote
#     products derived from this software without specific prior written
#     permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import optparse
import os
import sys
import subprocess

imageExt = ["alpha", "als", "anim", "bmp", "btf", "bw", "cin",
    "dib", "dpx", "epdf", "exr", "gfa", "gif", "giff", "icon", "iff", "img",
    "int", "inta", "jpe", "jpeg", "jpg", "mask", "matte", "pct",
    "pct1", "pct2", "pdb", "pdd", "pdf", "pic", "pict", "pix", "png",
    "psb", "psd", "raw", "rgb", "rgba", "rle", "rw2", "sgi", "tga",
    "tif", "tiff", "tpic"]

# Return two components if "filename" is formatted like a file in an
# image sequence otherwise return an empty list.  The two returned
# components are the full filename but missing the frame number,
# and the frame number.
#     Eg.  "a.b.c.001.exr" -> ["a.b.c.exr", "001"]
#
def seqSplit(filename) :

    fileComponents = filename.split(".")

    if (len(fileComponents) > 2
	    and imageExt.count(fileComponents[-1]) >= 1
	    and fileComponents[-2].isdigit()) :

	fileExt = fileComponents[-1]
	fileFrameNum = fileComponents[-2]
	fileComponents.remove(fileFrameNum)
	fileKey = ".".join(fileComponents)
	return [fileKey, fileFrameNum]
    else :
	return []

# Reconstruct the imagename with the frame number.
#
def actualImageName(filename, padding, frame) :
    fileComponents = filename.split(".")
    formatStr = "%0" + str(padding) + "d"
    fileComponents = fileComponents[:-1] + \
	[formatStr % frame] + [fileComponents[-1]]
    return ".".join(fileComponents)

# Frame sequence formats are the following
# e.g., 1, 3-5, 8, 10-20, 22-44x2
# Namely: sorted, comma-separated lists of individual frames,
# possibly interspersed with sequential lists of frames x-y
# (x through y), and stepped ranges "on N's" (like on 2's, or
# 3's etc) formatted thus: A-BxN (A through B on N's).
#
# note: "on n's" not yet implemented (showStepFrames)
# note: padding arg not yet used
#
def frameSequenceFormat(frameList, padding, showStepFrames) :
    frameList.sort()
    frameSeq = []

    if len(frameList) == 0 :
	return frameSeq

    isSequence = False
    frameSeq.append("%d" % frameList[0])

    if len(frameList) == 1 :
	return frameSeq

    prevFrame = frameList[0]
    frameList.pop(0)

    # Keep popping the first entry off the list of frames
    # and check to see if it's part of an uninterrupted
    # sequence, or if there's a break in the sequence.
    #
    while len(frameList) > 0 :
	if (frameList[0] - prevFrame) == 1 : # Means uninterrrupted seq.
	    if not isSequence : # This was the second number in sequence.
		#
		# Append a dash to the first frame in the sequence
		# in preperation for appending the last frame of the
		# sequence when we eventually find it.
		#
		frameSeq[-1] += "-"
		isSequence = True
	else :
	    if isSequence : # Record the last frame of the previous seq.
		frameSeq[-1] += ("%d" % prevFrame)
	    isSequence = False
	    frameSeq.append("%d" % frameList[0])

	prevFrame = frameList[0]
	frameList.pop(0)

    if isSequence : # Close off the final sequence if need be.
	frameSeq[-1] += ("%d" % prevFrame)

    return frameSeq

def printSeq(filename, frameList, options) :

    fileComponents = filename.split(".")
    missingFrames = []
    zeroFrames = []
    minFrame = frameList[1][0]
    maxFrame = frameList[1][-1]
    padding = frameList[0]
    i = minFrame
    while i <= maxFrame:
	iMissing = False
	if i != frameList[1][0] :
	    iMissing = True
	    if options.showMissing :
		missingFrames.append(i)
	else :
	    frameList[1].pop(0)
	if (not iMissing and options.showZero) :
	    actualFilename = actualImageName(filename, padding, i)
	    # Check to see if file exists - might be broken soft link.
	    if not os.path.exists(actualFilename) :
		zeroFrames.append(i)
		print >> sys.stderr, os.path.basename(sys.argv[0]) + ": warning: " + actualFilename + " is a broken soft link."
	    elif os.path.getsize(actualFilename) == 0 :
		zeroFrames.append(i)
	i = i + 1

    formatStr = "%0" + str(padding) + "d"
    if minFrame != maxFrame :
	frameRange = "[" \
	    + (formatStr % minFrame) \
	    + "-" \
	    + (formatStr % maxFrame) \
	    + "]"
    else :
	frameRange = "[" \
	    + (formatStr % minFrame) \
	    + "]"
    fileComponents = fileComponents[:-1] + [frameRange] + [fileComponents[-1]]
    print ".".join(fileComponents),
    errFrames = missingFrames + zeroFrames
    frameSeq = frameSequenceFormat(errFrames, 1, False)
    if (len(frameSeq) > 0) :
	sys.stdout.write(" [")
	doPrintComma = False
	for f in frameSeq :
	    if doPrintComma :
		sys.stdout.write(",")
	    sys.stdout.write(f)
	    doPrintComma = True
	sys.stdout.write("]")
    print ""

def listSeqDir(dirContents, path, listSubDirs, options, traversedPath) :

    tmpCWD = ""
    # Stash the current working dir, to come back to and the end
    # of this function.
    if (len(path) > 0) :
	tmpCWD = os.path.abspath(".")
	os.chdir(path)

    # The 'imageDictionary' has <imageName>.<ext> (no frame number) as
    # the key for each entry. Each entry is a two item list containing
    # a number and a list, namely:
    #     [ <framePadding>, [ list of frames ] ]
    #
    imageDictionary = {}
    otherFiles = []
    dirList = []

    # Go through the directory contents sifting out the various file types,
    # collect the names into various lists for printing after this is done.
    #
    for filename in dirContents:
	fileParts = seqSplit(filename)
	if len(fileParts) == 2 : # Means file is an image.
	    if imageDictionary.has_key(fileParts[0]) :
		# tack on new frame number.
		imageDictionary[fileParts[0]][1].append(int(fileParts[1]))
		# smallest length frame number determines padding.
		if (len(fileParts[1]) < imageDictionary[fileParts[0]][0]) :
		    imageDictionary[fileParts[0]][0] = len(fileParts[1])
	    else :
		# initialiaze dictionary entry.
		imageDictionary[fileParts[0]] \
		    = [len(fileParts[1]), [int(fileParts[1])]]
	else :
	    isFileDir = os.path.isdir(filename)
	    if ((not isFileDir
		    or not listSubDirs
		    or not options.listDirContents)
		    and not options.onlyImages):
		otherFiles.append(filename)
	    if isFileDir :
		dirList.append(filename)

    # Use actual "ls" to print non-image files nicely.
    # 
    otherFiles.sort()
    if len(otherFiles) > 0 :
	extra_ls_options = []
	if options.classify :
	    extra_ls_options = ["-F"]
	lsCmd = ["ls", "-d"] + extra_ls_options + otherFiles
	sys.stdout.flush()
	subprocess.call(lsCmd)
	sys.stdout.flush()

    # Now actually print the sequences in this directory.
    #
    imKeys = imageDictionary.keys()
    imKeys.sort()
    for k in imKeys :
	imageDictionary[k][1].sort()
	printSeq(k, imageDictionary[k], options)

    # lsseq - the contents of any subdirectories if need be.
    #
    if ((listSubDirs or options.isRecursive) and options.listDirContents) :
	dirList.sort()
	for d in dirList :
	    dir = d
	    if d[-1] == "/" :
		dir = d[:-1]
	    print ""
	    if options.isRecursive :
		print traversedPath + dir + ":"
	    else :
		print dir + ":"
	    listSeqDir(os.listdir(dir), dir, False, options,
		traversedPath + dir + "/")

    if (len(path) > 0) : os.chdir(tmpCWD)

def main():

    # Redefine the exception handling routine so that it does NOT
    # do a trace dump if the user types ^C while lsseq is running.
    #
    old_excepthook = sys.excepthook
    def new_hook(type, value, traceback):
	if type != KeyboardInterrupt and type != IOError:
	    old_excepthook(type, value, traceback)
	else:
	    pass
    sys.excepthook = new_hook

    p = optparse.OptionParser(
	description="List directory contents while compressing images sequences to one entry each. Filenames that are part of images sequences are assumed to be of the form <descriptiveName>.<frameNum>.<imgExtention>",
	version="1.141",
	usage="%prog [OPTION]... [FILE]...")

    p.add_option("--directory", "-d", action="store_false",
	dest="listDirContents", default=True,
	help="list directory entries instead of contents, and do not dereference symbolic links")
    p.add_option("--classify", "-F", action="store_true",
	dest="classify", default=False,
	help="append indicator (one of */=>@|) to entries")
    p.add_option("--showMissing", "-m", action="store_true",
	dest="showMissing", default=True,
	help="show list of missing frames [default]" )
    p.add_option("--skipMissing", "-M", action="store_false",
	dest="showMissing",
	help="do not show list of missing frames" )
    p.add_option("--onlyImages", "-o", action="store_true",
	dest="onlyImages", default=False,
	help="only list image sequences")
    # p.add_option("--imageList", "-i", action="store", type="string",
	# dest="imageList", metavar="FILE",
	# help="file containing list of raster image extentions")
    # p.add_option("--printImages", "-P", action="store_false",
	# dest="printImages",
	# help="print list of raster file image extensions and exit")
    # ***Change the next two to be a list [default, shake, nuke]
    # p.add_option("--nukeFormat", "-n", action="store_true",
	# dest="nukeFormat", default="False",
	# help="list images sequences in format suitable for nuke FileIn node")
    # p.add_option("--shakeFormat", "-s", action="store_true",
	# dest="shakeFormat", default="False",
	# help="list images sequences in format suitable for shake FileIn node")
    p.add_option("--recursive", "-R", action="store_true",
	dest="isRecursive", default=False,
	help="list subdirectories recursively")
    # p.add_option("--explicitList", "-x", action="store_true",
	# dest="explicitList", default=False,
	# help="Explicitly show each frame in the sequence list" )
    p.add_option("--showZero", "-z", action="store_true",
	dest="showZero", default=True,
	help="show list of zero length images [default]" )
    p.add_option("--skipZero", "-Z", action="store_false",
	dest="showZero",
	help="do not show list of zero length images" )

    (options, arguments) = p.parse_args()

    # The following logic attempts to mimic the behaviour
    # of /bin/ls as well as possible.

    # No args means list the current directory.
    #
    if len(arguments) == 0:
	if (not options.listDirContents) :
	    if (not options.onlyImages) :
		print "."
	else :
	    if options.isRecursive :
		print ".:"
		listSeqDir(os.listdir("."), "", False, options, "./")
	    else :
		listSeqDir(os.listdir("."), "", False, options, "")

    # We are being asked to list a specific directory, so we don't need 
    # to print the directory name before listing the contents (unless
    # it is a recursive listing).  (/bin/ls behaviour.)
    #
    elif len(arguments) == 1 and os.path.isdir(arguments[0]) :
	arg0 = arguments[0]
	# Strip out trailing "/" that may have been tacked on by
	# file completion.  (/bin/ls does not do this - but it's 
	# cleaner looking.)
	if arguments[0][-1] == "/" :
	    arg0 = arguments[0][:-1]
	if (not options.listDirContents) :
	    print arg0
	else :
	    if options.isRecursive:
		print arg0 + ":"
		listSeqDir(os.listdir(arg0), arg0, False, options, arg0 + "/")
	    else :
		listSeqDir(os.listdir(arg0), arg0, False, options, "")

    # List all the arguments on the command line and unless prevented by
    # the "-d" option, it will also list the contents of all the directories
    # entered on the command line as well.
    #
    else:
	listSeqDir(arguments, "", True, options, "")

if __name__ == '__main__':
    main()
