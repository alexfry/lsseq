#!/usr/bin/env python

# lsseq - List directory contents while compressing images sequences to
# one entry each.  Filenames that are part of images sequences are
# assumed to be of the form:
#     <descriptiveName>.<frameNum>.<imgExtension>

# Copyright (c) 2008-2012, James Philip Rowell,
# Orange Imagination & Concepts, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#   - Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#   - Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
#   - Neither the name "Orange Imagination & Concepts, Inc." nor the
#     names of its contributors may be used to endorse or promote
#     products derived from this software without specific prior written
#     permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import optparse
import os
import sys
import subprocess
import seqLister

MOV_EXT = ["avi", "mov", "mp4", "mpg", "wmv"]
IMAGE_EXT = ["alpha", "als", "anim", "bmp", "btf", "bw", "cin",
    "dib", "dpx", "exr", "gfa", "gif", "giff", "icon", "iff", "img",
    "int", "inta", "jpe", "jpeg", "jpg", "mask", "matte", "pct",
    "pct1", "pct2", "pdb", "pdd", "pic", "pict", "pix", "png",
    "psb", "psd", "raw", "rgb", "rgba", "rle", "rw2", "sgi", "tga",
    "tif", "tiff", "tpic"]


# Return two components if "filename" is formatted like a file in an
# image sequence otherwise return an empty list.  The two returned
# components are the full filename but missing the frame number,
# and the frame number (with its existing padding if any).
#     Eg.  "a.b.c.001.exr" -> ["a.b.c.exr", "001"]
#
def seqSplit(filename) :

    global IMAGE_EXT
    fileComponents = filename.split(".")

    if (len(fileComponents) > 2
            and IMAGE_EXT.count(fileComponents[-1]) >= 1
            and (fileComponents[-2].isdigit()
	         or (fileComponents[-2][0] == '-' and fileComponents[-2][1:].isdigit())
		)
	) :

        fileFrameNum = fileComponents[-2]
        fileComponents.remove(fileFrameNum)
        fileKey = ".".join(fileComponents)
        return [fileKey, fileFrameNum]
    else :
        return []


# Return true if and only if filename is a movie file.
#
def isMovie(filename) :
    global MOV_EXT
    fileComponents = filename.split(".")

    return len(fileComponents) > 1 and MOV_EXT.count(fileComponents[-1]) >= 1


# Reconstruct the imagename with the frame number.
#
def actualImageName(filename, padding, frame) :
    fileComponents = filename.split(".")
    formatStr = "{0:0=-" + str(padding) + "d}"
    fileComponents = fileComponents[:-1] + \
	[formatStr.format(frame)] + [fileComponents[-1]]
    return ".".join(fileComponents)


def printSeq(filename, frameList, options, traversedPath) :

    fileComponents = filename.split(".")
    missingFrames = []
    zeroFrames = []
    minFrame = frameList[1][0]
    maxFrame = frameList[1][-1]
    padding = frameList[0]
    i = minFrame
    while i <= maxFrame:
        iMissing = False
        if i != frameList[1][0] :
            iMissing = True
            if options.showMissing :
                missingFrames.append(i)
        else :
            frameList[1].pop(0)
        if (not iMissing and options.showZero) :
            actualFilename = actualImageName(filename, padding, i)
            # Check to see if file exists - might be broken soft link.
            if not os.path.exists(actualFilename) :
                zeroFrames.append(i)
                print >> sys.stderr, os.path.basename(sys.argv[0]) + ": warning: " + actualFilename + " is a broken soft link."
            elif os.path.getsize(actualFilename) == 0 :
                zeroFrames.append(i)
        i = i + 1

    formatStr = "%0" + str(padding) + "d"
    if minFrame != maxFrame :
	if options.rvCmd :
	    padStr = '@' * padding
	    if padding == 4 :
		padStr = '#'
	    frameRange = str(minFrame) + "-" + str(maxFrame) + padStr
	else :
	    frameRange = "[" \
		+ (formatStr % minFrame) \
		+ "-" \
		+ (formatStr % maxFrame) \
		+ "]"
    else :
	if options.rvCmd :
	    frameRange = (formatStr % minFrame)
	else :
	    frameRange = "[" \
		+ (formatStr % minFrame) \
		+ "]"
    fileComponents = fileComponents[:-1] + [frameRange] + [fileComponents[-1]]

    if options.nukeCmd :
        fileComponents[-2] = "%0" + str(padding) + "d"
        print "nukev",
        if options.prependPath :
            sys.stdout.write(traversedPath)
        print ".".join(fileComponents),
        print str(minFrame) + "," + str(maxFrame)
    elif options.shakeCmd :
        fileComponents[-2] = "#"
        print "shake -t", str(minFrame) + "-" + str(maxFrame),
        if options.prependPath :
            sys.stdout.write(traversedPath)
        print ".".join(fileComponents)
    else :
        if options.prependPath :
            sys.stdout.write(traversedPath)
        if options.extremes :
            fileComponents[-2] = formatStr % minFrame

        print ".".join(fileComponents),
        if minFrame != maxFrame and options.extremes :
            print ""
            sys.stdout.write(traversedPath)
            fileComponents[-2] = formatStr % maxFrame
            print ".".join(fileComponents),

        errFrames = missingFrames + zeroFrames
        frameSeq = seqLister.compressSeq(errFrames)
        if (len(frameSeq) > 0) :
            sys.stdout.write(" [")
            doPrintComma = False
            for f in frameSeq :
                if doPrintComma :
                    sys.stdout.write(",")
                sys.stdout.write(f)
                doPrintComma = True
            sys.stdout.write("]")
        print ""


def stripDotFiles(dirContents, stripIt) :
    if not stripIt:
	return dirContents
    else :
	strippedDirContents = []
	for f in dirContents :
	    if f[0] != "." :
		strippedDirContents.append(f)
	return strippedDirContents


def listSeqDir(dirContents, path, listSubDirs, options, traversedPath) :

    tmpCWD = ""
    # Stash the current working dir, to come back to and the end
    # of this function.
    if (len(path) > 0) :
        tmpCWD = os.path.abspath(".")
        os.chdir(path)

    # The 'imageDictionary' has <imageName>.<ext> (no frame number) as
    # the key for each entry. Each entry is a two item list containing
    # a number and a list, namely:
    #     [ <framePadding>, [ list of frames ] ]
    #
    imageDictionary = {}
    movFiles = []
    otherFiles = []
    dirList = []

    # Go through the directory contents sifting out the various file types,
    # collect the names into various lists for printing after this is done.
    #
    for filename in dirContents:
        fileParts = seqSplit(filename)
        if len(fileParts) == 2 : # Means file is an image.
	    newFrameNum = int(fileParts[1])
	    newPaddingSize = len(fileParts[1])
	    if newFrameNum < 0 and newFrameNum > -10 and newPaddingSize == 2:
		newPaddingSize -= 1
            if imageDictionary.has_key(fileParts[0]) :
                # tack on new frame number.
                imageDictionary[fileParts[0]][1].append(newFrameNum)
                # smallest length frame number determines padding.
                if (newPaddingSize < imageDictionary[fileParts[0]][0]) :
                    imageDictionary[fileParts[0]][0] = newPaddingSize
            else :
                # initialiaze dictionary entry.
                imageDictionary[fileParts[0]] \
                    = [newPaddingSize, [newFrameNum]]
	elif isMovie(filename) :
	    movFiles.append(filename)
        else :
            isFileDir = os.path.isdir(filename)
            if ((not isFileDir
                    or not listSubDirs
                    or not options.listDirContents)
                    and not options.onlyImages):
                otherFiles.append(filename)
            if isFileDir :
                dirList.append(filename)

    # Use actual "ls" to print non-image files nicely.
    #
    otherFiles.sort()
    if len(otherFiles) > 0 :
        extra_ls_options = []
        if options.classify :
            extra_ls_options.append("-F")
        if options.singleColumn :
            extra_ls_options.append("-1")
        lsCmd = ["ls", "-d"] + extra_ls_options + otherFiles
        sys.stdout.flush()
        subprocess.call(lsCmd)
        sys.stdout.flush()

    # Now actually print the sequences in this directory.
    #
    imKeys = imageDictionary.keys()
    for m in movFiles :
	imKeys.append(m)
    imKeys.sort()
    for k in imKeys :
	if isMovie(k) :
	    print k
	else :
	    imageDictionary[k][1].sort()
	    printSeq(k, imageDictionary[k], options, traversedPath)

    # lsseq - the contents of any subdirectories if need be.
    #
    if ((listSubDirs or options.isRecursive) and options.listDirContents) :
        dirList.sort()
        for d in dirList :
            if d[-1] == "/" :
                d = d[:-1]
            if not options.prependPath :
                print ""
                if options.isRecursive :
                    print traversedPath + d + ":"
                else :
                    print d + ":"
            listSeqDir(stripDotFiles(os.listdir(d), options.ignoreDotFiles), d, False, options,
                traversedPath + d + "/")

    if (len(path) > 0) :
        os.chdir(tmpCWD)


def main():

    # Redefine the exception handling routine so that it does NOT
    # do a trace dump if the user types ^C while lsseq is running.
    #
    old_excepthook = sys.excepthook
    def new_hook(exceptionType, value, traceback):
        if exceptionType != KeyboardInterrupt and exceptionType != IOError:
            old_excepthook(exceptionType, value, traceback)
        else:
            pass
    sys.excepthook = new_hook

    global IMAGE_EXT
    global MOV_EXT

    p = optparse.OptionParser(
        description="List directory contents while compressing images sequences to one entry each. Filenames that are part of images sequences are assumed to be of the form <descriptiveName>.<frameNum>.<imgExtension> - where imgExtension is drawn from a default list of image extensions (see option -i) or they can be set with the environment variable OIC_IMAGE_EXTENSION=exr:jpg:tif (for example).  Similarly there is an OIC_MOV_EXTENSION environment variable for movie file extensions.",
        version="1.500",
        usage="%prog [OPTION]... [FILE]...")

    p.add_option("--single", "-1", action="store_true",
        dest="singleColumn", default=False,
        help="list one non-image file per line")
    p.add_option("--all", "-a", action="store_false",
        dest="ignoreDotFiles", default=True,
        help="do not ignore entries starting with .")
    p.add_option("--directory", "-d", action="store_false",
        dest="listDirContents", default=True,
        help="list directory entries instead of contents, and do not dereference symbolic links")
    p.add_option("--extremes", "-e", action="store_true",
        dest="extremes", default=False,
        help="only list the first and last image on a separate line.  This option implies --prependPath, --onlyImages, --skipMissing and --skipZero.  The purpose of this option is to help in backing up image sequences - making it easy to get a list of only the first and last frame for each sequence.")
    p.add_option("--classify", "-F", action="store_true",
        dest="classify", default=False,
        help="append indicator (one of */=>@|) to entries")
    p.add_option("--imgExt", "-i", action="store_true",
        dest="printImgExtensions", default=False,
        help="print list of raster and movie file extensions and exit")
    p.add_option("--showMissing", "-m", action="store_true",
        dest="showMissing", default=True,
        help="show list of missing frames [default]" )
    p.add_option("--skipMissing", "-M", action="store_false",
        dest="showMissing",
        help="do not show list of missing frames" )
    p.add_option("--nuke", "-n", action="store_true",
        dest="nukeCmd", default=False,
        help="list image sequences as nuke viewer command lines (takes precedence over --shake option)")
    p.add_option("--onlyImages", "-o", action="store_true",
        dest="onlyImages", default=False,
        help="only list image sequences")
    p.add_option("--prependPath", "-p", action="store_true",
        dest="prependPath", default=False,
        help="prepend the abs path name to the image name. This option implies the option --onlyImages and will also suppress printing directory name headers when listing directory contents.")
    p.add_option("--shake", "-s", action="store_true",
        dest="shakeCmd", default=False,
        help="list image sequences as shake viewer command lines")
    p.add_option("--rv", "-r", action="store_true",
        dest="rvCmd", default=False,
        help="list image sequences as arguments suitable for the rv viewer")
    p.add_option("--recursive", "-R", action="store_true",
        dest="isRecursive", default=False,
        help="list subdirectories recursively")
    p.add_option("--showZero", "-z", action="store_true",
        dest="showZero", default=True,
        help="show list of zero length images [default]" )
    p.add_option("--skipZero", "-Z", action="store_false",
        dest="showZero",
        help="do not show list of zero length images" )

    (options, arguments) = p.parse_args()

    tmpExt = os.getenv("OIC_IMAGE_EXTENSION")
    if tmpExt != None and tmpExt != "" :
        IMAGE_EXT = tmpExt.split(":")

    tmpExt = os.getenv("OIC_MOV_EXTENSION")
    if tmpExt != None and tmpExt != "" :
        MOV_EXT = tmpExt.split(":")

    if options.printImgExtensions :
        print "Image extensions:", IMAGE_EXT
        print "Movie extensions:", MOV_EXT
        sys.exit(0)

    if options.extremes :
        options.prependPath = True
        options.showMissing = False
        options.showZero = False
        options.shakeCmd = False
        options.nukeCmd = False
        options.rvCmd = False

    if options.nukeCmd :
        options.shakeCmd = False

    if options.rvCmd :
        options.shakeCmd = False
        options.nukeCmd = False

    if options.prependPath :
        options.onlyImages = True # Force this.

    # The following logic attempts to mimic the behavior
    # of /bin/ls as well as possible.

    # No args means list the current directory.
    #
    if len(arguments) == 0:
        if (not options.listDirContents) :
            if (not options.onlyImages) :
                print "."
        else :
            if options.isRecursive :
                if not options.prependPath :
                    print ".:"
                passedPath = "./"
            else :
                passedPath = ""
            if options.prependPath :
                passedPath = os.getcwd() + "/"

            listSeqDir(stripDotFiles(os.listdir("."), options.ignoreDotFiles), "", False, options, passedPath)

    # We are being asked to list a specific directory, so we don't need
    # to print the directory name before listing the contents (unless
    # it is a recursive listing).  (/bin/ls behavior.)
    #
    elif len(arguments) == 1 and os.path.isdir(arguments[0]) :
        arg0 = arguments[0]
        # Strip out trailing "/" that may have been tacked on by
        # file completion.  (/bin/ls does not do this - but it's
        # cleaner looking.)
        if arguments[0][-1] == "/" :
            arg0 = arguments[0][:-1]
        if (not options.listDirContents) :
            print arg0
        else :
            if options.isRecursive:
                if not options.prependPath :
                    print arg0 + ":"
                passedPath = arg0 + "/"
            else :
                passedPath = ""
            if options.prependPath :
                passedPath = os.getcwd() + "/"

            listSeqDir(stripDotFiles(os.listdir(arg0), options.ignoreDotFiles), arg0, False, options, passedPath)

    # List all the arguments on the command line and unless prevented by
    # the "-d" option, it will also list the contents of all the directories
    # entered on the command line as well.
    #
    else:
        passedPath = ""
        if options.prependPath :
            passedPath = os.getcwd() + "/"
        listSeqDir(arguments, "", True, options, passedPath)

if __name__ == '__main__':
    main()
